<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alta Visual Editor Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <style>
        body { background: #e2e8f0; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; }
        
        /* TOOLBAR */
        .toolbar {
            background: #1e293b; color: white; padding: 10px 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 100; position: relative;
        }
        .btn-tool {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white;
            padding: 8px 15px; border-radius: 6px; margin-right: 8px; cursor: pointer;
        }
        .btn-tool:hover { background: rgba(255,255,255,0.2); }
        .btn-tool.active { background: #3b82f6; border-color: #3b82f6; }
        
        .btn-action { background: #10b981; color: white; border: none; padding: 8px 20px; border-radius: 6px; }
        
        /* CANVAS AREA */
        #editor-container {
            position: relative; overflow: auto; height: calc(100vh - 60px);
            background: #94a3b8; display: flex; justify-content: center; padding: 40px;
        }
        #pdf-wrapper { position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        
        /* FLOATING INPUT BOX (Draggable) */
        .floating-input {
            position: absolute; background: white; border: 2px dashed #3b82f6;
            padding: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 1000;
            cursor: move; display: flex; gap: 5px; align-items: center;
        }
        .floating-input input { border: none; outline: none; font-family: 'Courier', monospace; font-size: 14px; width: 150px; }
        .btn-mini { padding: 4px 8px; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 12px; }
        .btn-ok { background: #10b981; }
        .btn-cancel { background: #ef4444; }

    </style>
</head>
<body>

    <div class="toolbar">
        <div style="display:flex; align-items:center; gap: 15px;">
            <strong><i class="fas fa-edit"></i> Alta Editor</strong>
            
            <button class="btn-tool" onclick="document.getElementById('file-input').click()">
                <i class="fas fa-folder-open"></i> Open
            </button>
            <input type="file" id="file-input" accept="application/pdf" style="display:none">

            <div style="width:1px; height:20px; background:rgba(255,255,255,0.3);"></div>

            <button class="btn-tool active" id="btn-text" onclick="setTool('text')">
                <i class="fas fa-font"></i> Text Tool
            </button>
            <button class="btn-tool" id="btn-whiteout" onclick="setTool('whiteout')">
                <i class="fas fa-eraser"></i> Whiteout (Delete)
            </button>

            <button class="btn-tool" onclick="undo()">
                <i class="fas fa-undo"></i> Undo
            </button>
        </div>

        <div style="display:flex; align-items:center; gap: 10px;">
            <select id="font-select" style="padding: 5px; border-radius: 4px;">
                <option value="Courier">Bank Font (Courier)</option>
                <option value="Helvetica">Standard (Arial)</option>
            </select>
            <input type="number" id="font-size" value="12" style="width: 50px; padding: 5px; border-radius: 4px;">
            <button class="btn-action" onclick="savePDF()">Save & Download</button>
        </div>
    </div>

    <div id="editor-container">
        <div id="pdf-wrapper">
            <canvas id="pdf-canvas"></canvas>
            <canvas id="interaction-layer" style="position:absolute; top:0; left:0;"></canvas>
        </div>
    </div>

    <script>
        // CONFIG
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // STATE
        let pdfDoc = null;
        let pdfBytes = null;
        let scale = 1.5;
        let currentTool = 'text';
        let modifications = [];
        
        // DOM ELEMENTS
        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        const layer = document.getElementById('interaction-layer');
        const layerCtx = layer.getContext('2d');
        const wrapper = document.getElementById('pdf-wrapper');

        // 1. UPLOAD
        document.getElementById('file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            pdfBytes = await file.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({data: pdfBytes}).promise;
            renderPage(1);
        });

        // 2. RENDER
        async function renderPage(num) {
            const page = await pdfDoc.getPage(num);
            const viewport = page.getViewport({scale: scale});
            
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            layer.width = viewport.width;
            layer.height = viewport.height;
            wrapper.style.width = `${viewport.width}px`;
            wrapper.style.height = `${viewport.height}px`;

            await page.render({canvasContext: ctx, viewport: viewport}).promise;
            redraw();
        }

        // 3. INTERACTION
        let isDrawing = false;
        let startX, startY;

        layer.addEventListener('mousedown', e => {
            const rect = layer.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;

            if (currentTool === 'whiteout') {
                isDrawing = true;
            } else if (currentTool === 'text') {
                createFloatingInput(startX, startY);
            }
        });

        layer.addEventListener('mousemove', e => {
            if (!isDrawing) return;
            const rect = layer.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            redraw(); // Clear and redraw old mods
            // Draw current drag box (preview)
            layerCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            layerCtx.fillRect(startX, startY, currentX - startX, currentY - startY);
            layerCtx.strokeStyle = 'red';
            layerCtx.strokeRect(startX, startY, currentX - startX, currentY - startY);
        });

        layer.addEventListener('mouseup', e => {
            if (!isDrawing) return;
            isDrawing = false;
            const rect = layer.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            modifications.push({
                type: 'whiteout',
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            });
            redraw();
        });

        // 4. FLOATING INPUT (THE DRAG FEATURE)
        function createFloatingInput(x, y) {
            // Remove any existing inputs
            const existing = document.querySelector('.floating-input');
            if (existing) existing.remove();

            const div = document.createElement('div');
            div.className = 'floating-input';
            div.style.left = x + 'px';
            div.style.top = y + 'px';

            const input = document.createElement('input');
            input.placeholder = "Type here...";
            input.style.fontFamily = document.getElementById('font-select').value;
            input.style.fontSize = document.getElementById('font-size').value + 'px';
            
            // Auto-focus logic
            setTimeout(() => input.focus(), 50);

            // DRAGGABLE LOGIC FOR THE BOX
            let isDragging = false;
            let dragOffsetX, dragOffsetY;

            div.addEventListener('mousedown', (e) => {
                if(e.target !== input && e.target.tagName !== 'BUTTON') {
                    isDragging = true;
                    dragOffsetX = e.clientX - div.offsetLeft;
                    dragOffsetY = e.clientY - div.offsetTop;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    div.style.left = (e.clientX - dragOffsetX) + 'px';
                    div.style.top = (e.clientY - dragOffsetY) + 'px';
                }
            });

            document.addEventListener('mouseup', () => isDragging = false);

            // OK / CANCEL
            const btnOk = document.createElement('button');
            btnOk.className = 'btn-mini btn-ok';
            btnOk.innerHTML = '✔';
            btnOk.onclick = () => {
                const rect = wrapper.getBoundingClientRect(); // Get wrapper offset
                // Calculate position relative to canvas
                const finalX = div.offsetLeft;
                const finalY = div.offsetTop + 10; // Adjust for baseline roughly

                modifications.push({
                    type: 'text',
                    text: input.value,
                    x: finalX,
                    y: finalY,
                    font: document.getElementById('font-select').value,
                    size: parseInt(document.getElementById('font-size').value)
                });
                redraw();
                div.remove();
            };

            const btnCancel = document.createElement('button');
            btnCancel.className = 'btn-mini btn-cancel';
            btnCancel.innerHTML = '✖';
            btnCancel.onclick = () => div.remove();

            div.appendChild(input);
            div.appendChild(btnOk);
            div.appendChild(btnCancel);
            wrapper.appendChild(div);
        }

        // 5. CORE LOGIC
        function setTool(t) {
            currentTool = t;
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + t).classList.add('active');
        }

        function undo() {
            modifications.pop();
            redraw();
        }

        function redraw() {
            layerCtx.clearRect(0, 0, layer.width, layer.height);
            modifications.forEach(mod => {
                if (mod.type === 'whiteout') {
                    layerCtx.fillStyle = 'white';
                    layerCtx.fillRect(mod.x, mod.y, mod.width, mod.height);
                } else if (mod.type === 'text') {
                    layerCtx.font = `${mod.size}px ${mod.font === 'Courier' ? 'Courier New' : 'Helvetica'}`;
                    layerCtx.fillStyle = 'black';
                    layerCtx.fillText(mod.text, mod.x, mod.y);
                }
            });
        }

        // 6. SAVE
        async function savePDF() {
            if (!pdfBytes) return;
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const page = pdfDoc.getPages()[0];
            const { height } = page.getSize();
            
            const courier = await pdfDoc.embedFont(StandardFonts.Courier);
            const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);

            modifications.forEach(mod => {
                const pdfX = mod.x / scale;
                const pdfY = height - (mod.y / scale);

                if (mod.type === 'whiteout') {
                    page.drawRectangle({
                        x: pdfX, y: pdfY - (mod.height/scale),
                        width: mod.width/scale, height: mod.height/scale,
                        color: rgb(1,1,1)
                    });
                } else if (mod.type === 'text') {
                    page.drawText(mod.text, {
                        x: pdfX, y: pdfY - (mod.size/scale), // slight baseline adjust
                        size: mod.size/scale,
                        font: mod.font === 'Courier' ? courier : helvetica,
                        color: rgb(0,0,0)
                    });
                }
            });

            const data = await pdfDoc.save();
            const blob = new Blob([data], {type: 'application/pdf'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'fixed_document.pdf';
            link.click();
        }
    </script>
</body>
</html>
