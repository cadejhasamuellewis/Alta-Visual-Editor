<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Alta Bank-Grade PDF Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <style>
    :root {
      --toolbar-bg: #222222;
      --toolbar-text: #f3f3f3;
      --accent: #3b82f6;
      --accent-2: #60a5fa;
      --border: #444;
      --panel: #1a1a1a;
      --canvas-bg: #4b4f55;
      --selection: rgba(59, 130, 246, 0.18);
      --selection-border: #3b82f6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, sans-serif;
      background: #2f343a;
      color: #111;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Toolbar */
    .toolbar {
      position: sticky;
      top: 0;
      z-index: 2000;
      height: 56px;
      background: var(--toolbar-bg);
      color: var(--toolbar-text);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .brand { font-weight: 700; letter-spacing: 1px; margin-right: 10px; color: #fff; }
    .tool-btn, .pill {
      background: transparent;
      color: var(--toolbar-text);
      border: 1px solid transparent;
      border-radius: 6px;
      padding: 6px 10px;
      height: 36px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all .15s;
      font-size: 13px;
    }
    .tool-btn:hover { background: rgba(255,255,255,0.08); }
    .tool-btn.active { background: #333; border-color: #555; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); }
    .divider { width: 1px; height: 24px; background: #444; margin: 0 4px; }
    select, input[type=number] {
      background: var(--panel);
      color: #fff;
      border: 1px solid var(--border);
      border-radius: 4px;
      height: 32px;
      padding: 4px 8px;
    }
    input[type=color] {
      width: 40px; height: 32px;
      border: 1px solid var(--border);
      border-radius: 4px; padding: 0;
      background: var(--panel);
    }
    .slider-group {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #ddd;
      font-size: 12px;
    }
    .slider-group input[type=range] { width: 120px; }
    /* Floating property bar area */
    .prop-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-left: 1px solid #444;
      margin-left: 6px;
    }
    /* Workspace */
    #workspace {
      flex: 1;
      background: var(--canvas-bg);
      overflow: auto;
      position: relative;
      padding: 32px;
      display: flex;
      justify-content: center;
    }
    #canvas-wrapper {
      position: relative;
      background: #fff;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      transform-origin: top left;
      user-select: none;
    }
    #pdf-canvas, #overlay {
      position: absolute;
      top: 0; left: 0;
    }
    #pdf-canvas { z-index: 1; }
    #overlay { z-index: 2; }
    /* Selection */
    .selection-box {
      position: absolute;
      border: 2px solid var(--selection-border);
      background: var(--selection);
      pointer-events: none;
      z-index: 10;
    }
    .handle {
      position: absolute;
      width: 10px; height: 10px;
      background: #fff;
      border: 2px solid var(--selection-border);
      border-radius: 2px;
      z-index: 11;
      transform: translate(-50%, -50%);
      pointer-events: all;
      cursor: pointer;
    }
    .handle.nw { top: 0; left: 0; cursor: nwse-resize; }
    .handle.ne { top: 0; left: 100%; cursor: nesw-resize; }
    .handle.sw { top: 100%; left: 0; cursor: nesw-resize; }
    .handle.se { top: 100%; left: 100%; cursor: nwse-resize; }
    /* Upload overlay */
    .dropzone {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
      z-index: 3000;
      font-size: 18px;
    }
    .dropzone.show { display: flex; }
    .zoom-hint {
      position: fixed;
      right: 16px; bottom: 16px;
      background: rgba(0,0,0,0.55);
      color: #eee;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 3500;
    }
    /* Buttons */
    .btn-ghost { background: rgba(255,255,255,0.08); border-color: #666; }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <span class="brand">ALTA BANK PRO</span>
    <button class="tool-btn" id="open-btn"><i class="fa-solid fa-folder-open"></i>Open</button>
    <button class="tool-btn" id="save-btn" disabled><i class="fa-solid fa-floppy-disk"></i>Save</button>
    <div class="divider"></div>
    <button class="tool-btn active" data-tool="select"><i class="fa-solid fa-arrow-pointer"></i>Select</button>
    <button class="tool-btn" data-tool="text"><i class="fa-solid fa-i-cursor"></i>Text</button>
    <button class="tool-btn" data-tool="whiteout"><i class="fa-solid fa-eraser"></i>Whiteout</button>
    <button class="tool-btn" data-tool="image"><i class="fa-solid fa-image"></i>Image</button>
    <div class="divider"></div>

    <!-- Property bar (shows for selected objects) -->
    <div class="prop-bar" id="prop-bar">
      <label style="color:#ccc;font-size:12px;">Font</label>
      <select id="font-family">
        <option value="Helvetica">Helvetica</option>
        <option value="Courier">Courier</option>
        <option value="TimesRoman">Times</option>
        <option value="BankCourier">Bank Courier</option>
      </select>
      <input type="number" id="font-size" min="6" max="72" value="12" style="width:60px;" />
      <input type="color" id="font-color" value="#000000" />
      <div class="slider-group">
        <span>Letter Spacing</span>
        <input type="range" id="letter-spacing" min="-2" max="10" step="0.1" value="0" />
        <span id="ls-val">0px</span>
      </div>
      <div class="slider-group">
        <span>Stretch</span>
        <input type="range" id="stretch" min="50" max="150" step="1" value="100" />
        <span id="stretch-val">100%</span>
      </div>
    </div>

    <div class="divider"></div>
    <button class="tool-btn btn-ghost" id="zoom-out"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
    <button class="tool-btn btn-ghost" id="zoom-in"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
    <span style="min-width:60px; text-align:center; font-size:12px; color:#ccc;" id="zoom-label">100%</span>
    <div class="divider"></div>
    <button class="tool-btn btn-ghost" id="delete-btn" title="Delete (Del)"><i class="fa-solid fa-trash"></i></button>
  </div>

  <!-- Workspace -->
  <div id="workspace">
    <div id="canvas-wrapper">
      <canvas id="pdf-canvas"></canvas>
      <canvas id="overlay"></canvas>
    </div>
    <div class="dropzone" id="dropzone">
      <i class="fa-solid fa-file-arrow-up fa-2xl"></i>
      <div>Drop PDF here to open</div>
    </div>
  </div>
  <div class="zoom-hint">Tip: Ctrl + Scroll to Zoom</div>

  <input type="file" id="file-input" accept="application/pdf" style="display:none" />
  <input type="file" id="img-input" accept="image/png,image/jpeg" style="display:none" />

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // State
    const state = {
      pdfDoc: null,
      pdfBytes: null,
      pdfLibDoc: null,
      pageNum: 1,
      scale: 1.2,
      tool: 'select',
      objects: [], // {id,type,x,y,w,h,text,font,size,color,ls,stretch,imgData}
      selectedId: null,
      dragging: false,
      resizing: false,
      resizeHandle: null,
      dragOffset: {x:0,y:0},
      startBox: {x:0,y:0},
      hover: null,
    };

    const canvas = document.getElementById('pdf-canvas');
    const overlay = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const octx = overlay.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');
    const propBar = document.getElementById('prop-bar');

    const fileInput = document.getElementById('file-input');
    const imgInput = document.getElementById('img-input');
    const dropzone = document.getElementById('dropzone');
    const zoomLabel = document.getElementById('zoom-label');

    const fontSel = document.getElementById('font-family');
    const fontSizeInput = document.getElementById('font-size');
    const fontColorInput = document.getElementById('font-color');
    const lsInput = document.getElementById('letter-spacing');
    const stretchInput = document.getElementById('stretch');
    const lsVal = document.getElementById('ls-val');
    const stretchVal = document.getElementById('stretch-val');

    const tools = document.querySelectorAll('[data-tool]');

    // Helpers
    const genId = () => crypto.randomUUID();

    function setStatusZoom() {
      zoomLabel.textContent = Math.round(state.scale*100) + '%';
      wrapper.style.transform = `scale(${state.scale})`;
    }

    function setTool(tool) {
      state.tool = tool;
      tools.forEach(t => t.classList.toggle('active', t.dataset.tool === tool));
      if (tool === 'select') overlay.style.cursor = 'default';
      else if (tool === 'image') overlay.style.cursor = 'copy';
      else overlay.style.cursor = 'crosshair';
    }

    // Load PDF
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await openPdfFile(file);
    });

    async function openPdfFile(file) {
      state.pdfBytes = await file.arrayBuffer();
      state.pdfDoc = await pdfjsLib.getDocument({data: state.pdfBytes}).promise;
      state.pdfLibDoc = await PDFLib.PDFDocument.load(state.pdfBytes);
      state.pageNum = 1;
      state.objects = [];
      state.selectedId = null;
      document.getElementById('save-btn').disabled = false;
      await renderPage();
    }

    async function renderPage() {
      const page = await state.pdfDoc.getPage(state.pageNum);
      const viewport = page.getViewport({ scale: state.scale });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      overlay.width = viewport.width;
      overlay.height = viewport.height;
      wrapper.style.width = viewport.width + 'px';
      wrapper.style.height = viewport.height + 'px';
      await page.render({canvasContext: ctx, viewport}).promise;
      redrawOverlay();
    }

    function redrawOverlay() {
      octx.clearRect(0,0,overlay.width, overlay.height);
      // draw objects
      for (const obj of state.objects) {
        drawObject(obj);
      }
      // selection
      if (state.selectedId) {
        const obj = state.objects.find(o=>o.id===state.selectedId);
        if (obj) drawSelection(obj);
      }
    }

    function drawObject(obj) {
      if (obj.type === 'whiteout') {
        octx.fillStyle = 'white';
        octx.fillRect(obj.x, obj.y, obj.w, obj.h);
      } else if (obj.type === 'text') {
        const font = mapCanvasFont(obj);
        octx.save();
        octx.fillStyle = obj.color || '#000';
        octx.font = font;
        octx.textBaseline = 'alphabetic';
        octx.letterSpacing = (obj.ls || 0) + 'px'; // some browsers support; fallback handled by manual measure if not
        octx.translate(obj.x, obj.y);
        octx.scale(obj.stretch || 1, 1);
        drawTextWithSpacing(octx, obj.text, 0, 0, obj.ls || 0);
        octx.restore();
      } else if (obj.type === 'image' && obj.img) {
        octx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
      }
    }

    function drawTextWithSpacing(ctx2d, text, x, y, ls) {
      // Fallback letter spacing drawing
      const letters = text.split('');
      let cursor = x;
      for (const ch of letters) {
        ctx2d.fillText(ch, cursor, y);
        cursor += ctx2d.measureText(ch).width + ls;
      }
    }

    function drawSelection(obj) {
      const pad = 4;
      const x = obj.x - pad, y = obj.y - pad, w = obj.w + pad*2, h = obj.h + pad*2;
      octx.save();
      octx.strokeStyle = '#3b82f6';
      octx.lineWidth = 2;
      octx.setLineDash([4,3]);
      octx.strokeRect(x, y, w, h);
      octx.setLineDash([]);
      octx.restore();
      // handles
      const handles = [
        {cls:'nw', hx:x, hy:y},
        {cls:'ne', hx:x+w, hy:y},
        {cls:'sw', hx:x, hy:y+h},
        {cls:'se', hx:x+w, hy:y+h},
      ];
      handles.forEach(h=>{
        octx.fillStyle = '#fff';
        octx.strokeStyle = '#3b82f6';
        octx.lineWidth = 2;
        octx.beginPath();
        octx.rect(h.hx-5, h.hy-5, 10, 10);
        octx.fill(); octx.stroke();
      });
    }

    // Hit testing
    function hitTest(x, y) {
      for (let i=state.objects.length-1; i>=0; i--) {
        const o = state.objects[i];
        if (x>=o.x && x<=o.x+o.w && y>=o.y && y<=o.y+o.h) return o;
      }
      return null;
    }

    // Mouse handlers
    overlay.addEventListener('mousedown', (e)=>{
      const {x,y} = getPos(e);
      state.startBox = {x,y};
      if (state.tool === 'select') {
        const obj = hitTest(x,y);
        state.selectedId = obj ? obj.id : null;
        if (obj) {
          // check handles
          const handle = whichHandle(obj, x, y);
          if (handle) {
            state.resizing = true;
            state.resizeHandle = handle;
          } else {
            state.dragging = true;
            state.dragOffset = {x: x - obj.x, y: y - obj.y};
          }
          syncPropBar(obj);
        } else {
          syncPropBar(null);
        }
        redrawOverlay();
      } else if (state.tool === 'whiteout') {
        state.dragging = true;
      } else if (state.tool === 'text') {
        state.dragging = false;
      } else if (state.tool === 'image') {
        imgInput.click();
      }
    });

    overlay.addEventListener('mousemove', (e)=>{
      const {x,y} = getPos(e);
      if (state.dragging && state.selectedId) {
        const obj = state.objects.find(o=>o.id===state.selectedId);
        if (obj) {
          obj.x = x - state.dragOffset.x;
          obj.y = y - state.dragOffset.y;
          redrawOverlay();
        }
      } else if (state.resizing && state.selectedId) {
        const obj = state.objects.find(o=>o.id===state.selectedId);
        if (obj) {
          resizeObject(obj, state.resizeHandle, x, y);
          redrawOverlay();
        }
      } else if (state.tool === 'whiteout' && state.dragging) {
        redrawOverlay();
        octx.save();
        octx.strokeStyle = '#3b82f6';
        octx.setLineDash([5,3]);
        octx.strokeRect(state.startBox.x, state.startBox.y, x - state.startBox.x, y - state.startBox.y);
        octx.restore();
      }
    });

    overlay.addEventListener('mouseup', (e)=>{
      const {x,y} = getPos(e);
      if (state.tool === 'whiteout' && state.dragging) {
        const w = x - state.startBox.x;
        const h = y - state.startBox.y;
        if (Math.abs(w) > 4 && Math.abs(h) > 4) {
          const obj = {
            id: genId(),
            type: 'whiteout',
            x: Math.min(state.startBox.x, x),
            y: Math.min(state.startBox.y, y),
            w: Math.abs(w),
            h: Math.abs(h),
          };
          state.objects.push(obj);
          state.selectedId = obj.id;
          syncPropBar(obj);
        }
      } else if (state.tool === 'text' && !state.dragging) {
        promptText(x,y);
      }
      state.dragging = false;
      state.resizing = false;
      state.resizeHandle = null;
      redrawOverlay();
    });

    function whichHandle(obj, x, y) {
      const pad=4;
      const boxes = {
        nw: {x: obj.x-pad, y: obj.y-pad},
        ne: {x: obj.x+obj.w+pad, y: obj.y-pad},
        sw: {x: obj.x-pad, y: obj.y+obj.h+pad},
        se: {x: obj.x+obj.w+pad, y: obj.y+obj.h+pad},
      };
      for (const k in boxes) {
        const b = boxes[k];
        if (Math.abs(x-b.x)<=8 && Math.abs(y-b.y)<=8) return k;
      }
      return null;
    }

    function resizeObject(obj, handle, x, y) {
      const minSize = 8;
      if (handle==='nw') {
        const nx = Math.min(obj.x+obj.w-minSize, x);
        const ny = Math.min(obj.y+obj.h-minSize, y);
        obj.w = obj.x+obj.w - nx;
        obj.h = obj.y+obj.h - ny;
        obj.x = nx; obj.y = ny;
      } else if (handle==='ne') {
        const ny = Math.min(obj.y+obj.h-minSize, y);
        obj.w = Math.max(minSize, x - obj.x);
        obj.h = obj.y+obj.h - ny;
        obj.y = ny;
      } else if (handle==='sw') {
        const nx = Math.min(obj.x+obj.w-minSize, x);
        obj.w = obj.x+obj.w - nx;
        obj.h = Math.max(minSize, y - obj.y);
        obj.x = nx;
      } else if (handle==='se') {
        obj.w = Math.max(minSize, x - obj.x);
        obj.h = Math.max(minSize, y - obj.y);
      }
    }

    function getPos(e) {
      const rect = overlay.getBoundingClientRect();
      const x = (e.clientX - rect.left) / state.scale;
      const y = (e.clientY - rect.top) / state.scale;
      return {x,y};
    }

    // Prompt text entry
    function promptText(x,y) {
      const text = prompt('Enter text:');
      if (!text) return;
      const font = fontSel.value;
      const size = parseInt(fontSizeInput.value, 10) || 12;
      const color = fontColorInput.value || '#000000';
      const ls = parseFloat(lsInput.value) || 0;
      const stretch = (parseInt(stretchInput.value,10)||100)/100;
      // measure
      octx.save();
      octx.font = `${size}px ${mapFontFamily(font)}`;
      const width = measureSpacing(octx, text, ls) * stretch;
      const height = size*1.2;
      octx.restore();
      const obj = {
        id: genId(),
        type: 'text',
        text,
        x, y,
        w: width,
        h: height,
        font,
        size,
        color,
        ls,
        stretch,
      };
      state.objects.push(obj);
      state.selectedId = obj.id;
      syncPropBar(obj);
    }

    function measureSpacing(ctx2d, text, ls) {
      const letters = text.split('');
      let w = 0;
      for (const ch of letters) {
        w += ctx2d.measureText(ch).width + ls;
      }
      return w - ls; // remove trailing spacing
    }

    function mapFontFamily(f) {
      if (f === 'Courier' || f === 'BankCourier') return 'Courier New, monospace';
      if (f === 'TimesRoman') return 'Times New Roman, serif';
      return 'Helvetica, Arial, sans-serif';
    }
    function mapCanvasFont(obj) {
      return `${obj.size}px ${mapFontFamily(obj.font)}`;
    }

    function syncPropBar(obj) {
      if (!obj || obj.type!=='text') {
        return;
      }
      fontSel.value = obj.font;
      fontSizeInput.value = obj.size;
      fontColorInput.value = obj.color || '#000000';
      lsInput.value = obj.ls ?? 0;
      stretchInput.value = Math.round((obj.stretch ?? 1)*100);
      lsVal.textContent = (obj.ls ?? 0) + 'px';
      stretchVal.textContent = Math.round((obj.stretch ?? 1)*100) + '%';
    }

    // Property change
    fontSel.addEventListener('change', ()=>updateSelectedProps());
    fontSizeInput.addEventListener('change', ()=>updateSelectedProps());
    fontColorInput.addEventListener('change', ()=>updateSelectedProps());
    lsInput.addEventListener('input', ()=>{
      lsVal.textContent = lsInput.value + 'px';
      updateSelectedProps();
    });
    stretchInput.addEventListener('input', ()=>{
      stretchVal.textContent = stretchInput.value + '%';
      updateSelectedProps();
    });

    function updateSelectedProps() {
      const obj = state.objects.find(o=>o.id===state.selectedId);
      if (!obj || obj.type!=='text') return;
      obj.font = fontSel.value;
      obj.size = parseInt(fontSizeInput.value,10)||obj.size;
      obj.color = fontColorInput.value;
      obj.ls = parseFloat(lsInput.value)||0;
      obj.stretch = (parseInt(stretchInput.value,10)||100)/100;
      // recompute width/height
      octx.save();
      octx.font = `${obj.size}px ${mapFontFamily(obj.font)}`;
      const width = measureSpacing(octx, obj.text, obj.ls) * obj.stretch;
      obj.w = width;
      obj.h = obj.size*1.2;
      octx.restore();
      // Bank Courier defaults
      if (obj.font === 'BankCourier' && lsInput.value === "") {
        obj.ls = -0.5;
      }
      redrawOverlay();
    }

    // Delete
    document.getElementById('delete-btn').addEventListener('click', deleteSelected);
    function deleteSelected() {
      if (!state.selectedId) return;
      state.objects = state.objects.filter(o=>o.id!==state.selectedId);
      state.selectedId = null;
      redrawOverlay();
    }

    // Keyboard
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Delete' || e.key === 'Backspace') {
        deleteSelected();
      }
      if (state.selectedId) {
        const obj = state.objects.find(o=>o.id===state.selectedId);
        if (!obj) return;
        let moved=false;
        const step = e.shiftKey ? 10 : 1;
        if (e.key === 'ArrowLeft') { obj.x -= step; moved=true; }
        else if (e.key === 'ArrowRight') { obj.x += step; moved=true; }
        else if (e.key === 'ArrowUp') { obj.y -= step; moved=true; }
        else if (e.key === 'ArrowDown') { obj.y += step; moved=true; }
        if (moved) { e.preventDefault(); redrawOverlay(); }
      }
    });

    // Zoom controls + ctrl-scroll
    document.getElementById('zoom-in').addEventListener('click', ()=>{ state.scale = Math.min(state.scale+0.1, 4); setStatusZoom(); renderPage(); });
    document.getElementById('zoom-out').addEventListener('click', ()=>{ state.scale = Math.max(state.scale-0.1, 0.4); setStatusZoom(); renderPage(); });
    overlay.addEventListener('wheel', (e)=>{
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY < 0 ? 0.1 : -0.1;
        state.scale = Math.min(4, Math.max(0.4, state.scale + delta));
        setStatusZoom();
        renderPage();
      }
    }, {passive:false});

    // Open/save buttons
    document.getElementById('open-btn').addEventListener('click', ()=>fileInput.click());
    document.getElementById('save-btn').addEventListener('click', savePDF);

    // Image upload
    imgInput.addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = ()=>{
        const w = img.width, h = img.height;
        const obj = { id: genId(), type:'image', x:40, y:40, w: w/2, h:h/2, img, imgFile:file };
        state.objects.push(obj);
        state.selectedId = obj.id;
        redrawOverlay();
      };
      img.src = URL.createObjectURL(file);
    });

    // Whiteout drag fix
    overlay.addEventListener('mouseleave', ()=>{ state.dragging=false; state.resizing=false; });

    // Save (burn in)
    async function savePDF() {
      if (!state.pdfLibDoc) return;
      const pdfDoc = await PDFLib.PDFDocument.load(state.pdfBytes);
      const page = pdfDoc.getPages()[state.pageNum-1];
      const { height } = page.getSize();

      const fontCache = {};
      async function getFont(family, weight='reg') {
        const key = `${family}-${weight}`;
        if (fontCache[key]) return fontCache[key];
        let font;
        if (family === 'Courier' || family === 'BankCourier') {
          font = await pdfDoc.embedFont(weight==='bold' ? PDFLib.StandardFonts.CourierBold : PDFLib.StandardFonts.Courier);
        } else if (family === 'TimesRoman') {
          font = await pdfDoc.embedFont(weight==='bold' ? PDFLib.StandardFonts.TimesRomanBold : PDFLib.StandardFonts.TimesRoman);
        } else {
          font = await pdfDoc.embedFont(weight==='bold' ? PDFLib.StandardFonts.HelveticaBold : PDFLib.StandardFonts.Helvetica);
        }
        fontCache[key]=font;
        return font;
      }

      for (const obj of state.objects) {
        if (obj.type === 'whiteout') {
          page.drawRectangle({
            x: obj.x / state.scale,
            y: height - (obj.y + obj.h)/state.scale,
            width: obj.w / state.scale,
            height: obj.h / state.scale,
            color: PDFLib.rgb(1,1,1)
          });
        } else if (obj.type === 'text') {
          const font = await getFont(obj.font);
          const colorRgb = hexToRgb(obj.color||'#000000');
          const size = obj.size / state.scale;
          const ls = (obj.ls||0) / state.scale;
          const stretch = obj.stretch || 1;

          // Manual letter rendering for spacing/stretch
          let cursorX = obj.x / state.scale;
          const baseY = height - (obj.y)/state.scale;
          for (const ch of obj.text.split('')) {
            const w = font.widthOfTextAtSize(ch, size) * stretch;
            page.drawText(ch, {
              x: cursorX,
              y: baseY,
              size,
              font,
              color: PDFLib.rgb(colorRgb.r/255, colorRgb.g/255, colorRgb.b/255),
              xScale: stretch
            });
            cursorX += w + ls;
          }
        } else if (obj.type === 'image' && obj.imgFile) {
          const imgBytes = await obj.imgFile.arrayBuffer();
          let embed;
          if (obj.imgFile.type === 'image/png') embed = await pdfDoc.embedPng(imgBytes);
          else embed = await pdfDoc.embedJpg(imgBytes);
          const pngDims = embed.scale(1);
          const w = obj.w / state.scale;
          const h = obj.h / state.scale;
          const x = obj.x / state.scale;
          const y = height - (obj.y + obj.h)/state.scale;
          page.drawImage(embed, { x, y, width: w, height: h });
        }
      }

      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes], {type:'application/pdf'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'bank-edit.pdf'; a.click();
      URL.revokeObjectURL(url);
    }

    function hexToRgb(hex) {
      const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return res ? {r: parseInt(res[1],16), g: parseInt(res[2],16), b: parseInt(res[3],16)} : {r:0,g:0,b:0};
    }

    // Drag-drop PDF
    ['dragenter','dragover'].forEach(ev=>{
      document.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.add('show');
      });
    });
    ['dragleave','drop'].forEach(ev=>{
      document.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        if (ev==='drop') {
          const f = e.dataTransfer.files[0];
          if (f && f.type==='application/pdf') openPdfFile(f);
        }
        dropzone.classList.remove('show');
      });
    });

    // Init
    setTool('select');
    setStatusZoom();
    tools.forEach(btn=>{
      btn.addEventListener('click', ()=>setTool(btn.dataset.tool));
    });
  </script>
</body>
</html>
