<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Alta Pro - Bank Grade Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Courier Prime used to mimic “Bank Courier” -->
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" rel="stylesheet" />

  <!-- PDF.js / PDF-Lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <style>
    :root {
      --bg-body: #f5f6f8;
      --bg-panel: #ffffff;
      --border: #e5e7eb;
      --accent: #cceeff;
      --accent-dark: #8ecae6;
      --accent-text: #0b5c80;
      --text-main: #1e293b;
      --shadow: 0 4px 10px rgba(0,0,0,0.08);
      --handle: #cceeff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: 'Inter', sans-serif;
      background: var(--bg-body); color: var(--text-main);
      display: flex; flex-direction: column; height: 100vh; overflow: hidden;
    }
    /* Toolbar */
    .toolbar {
      height: 64px; background: var(--bg-panel); border-bottom: 1px solid var(--border);
      display: flex; align-items: center; padding: 8px 16px; gap: 12px;
      box-shadow: var(--shadow); z-index: 100;
    }
    .group { display: flex; align-items: center; gap: 10px; }
    .divider { width:1px; height:28px; background: var(--border); margin: 0 6px; }
    .btn {
      background: transparent; border: 1px solid transparent; border-radius: 6px;
      padding: 6px 10px; min-width: 48px; height: 36px;
      display: inline-flex; align-items: center; justify-content: center; gap: 6px;
      color: #667085; font-size: 12px; font-weight: 600; cursor: pointer; transition: all .15s;
    }
    .btn i { font-size: 15px; }
    .btn:hover { background: #f8fafc; color: var(--accent-text); }
    .btn.active {
      background: var(--accent); color: var(--accent-text);
      border-color: var(--accent-dark); box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
    }
    /* Property bar */
    .prop-bar {
      height: 52px; background: #fff; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; padding: 0 16px; gap: 12px;
    }
    select, input[type=number], input[type=color] {
      height: 32px; border: 1px solid var(--border); border-radius: 4px;
      padding: 0 8px; font-size: 12px; color: #334155; background: #fff;
    }
    input[type=number] { width: 60px; }
    input[type=color] { width: 36px; padding: 0; border: 1px solid var(--border); }
    .toggle {
      width: 32px; height: 32px; border: 1px solid var(--border);
      border-radius: 4px; background: #fff; cursor: pointer; font-weight: 700;
      display:flex; align-items:center; justify-content:center;
    }
    .toggle.toggled { background: #333; color: #fff; border-color: #111; }
    .slider-wrap { display:flex; align-items:center; gap:8px; font-size:12px; color:#475569; }
    .slider-wrap input[type=range]{ width: 120px; }
    /* Workspace */
    #workspace {
      flex: 1; overflow: auto; background: #e2e8f0;
      display: flex; justify-content: center; padding: 32px; position: relative;
    }
    #canvas-wrapper {
      position: relative; background: #fff; box-shadow: 0 10px 20px rgba(0,0,0,0.12);
      transform-origin: top left;
    }
    canvas { position: absolute; top:0; left:0; }
    #pdf-canvas { z-index:1; }
    #overlay { z-index:2; }
    /* Inline textarea editor */
    #text-editor {
      position: absolute; z-index: 30; display: none;
      background: transparent; border: 1px dashed var(--accent-text);
      padding: 0; margin: 0; resize: none; overflow: hidden; white-space: pre;
      line-height: 1.1; transform-origin: top left;
    }
    /* Selection */
    .selection-box {
      position: absolute; border: 2px solid var(--accent);
      background: rgba(204,238,255,0.2); pointer-events: none; z-index: 15;
    }
    .handle {
      position: absolute; width: 10px; height: 10px; background: #fff;
      border: 2px solid var(--accent-dark); border-radius: 2px; z-index: 16;
      transform: translate(-50%,-50%); pointer-events: all;
    }
    /* Drop overlay */
    .drop-overlay {
      position: fixed; inset:0; background: rgba(255,255,255,0.9);
      display: none; align-items: center; justify-content: center; flex-direction: column;
      z-index: 3000; color: var(--accent-text); gap: 8px;
    }
    .drop-overlay.active { display: flex; }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="group">
      <strong style="color:#0f172a;">ALTA PRO</strong>
      <div class="divider"></div>
      <button class="btn" id="open-btn"><i class="fa-regular fa-folder-open"></i>Open</button>
      <button class="btn" id="save-btn" disabled><i class="fa-regular fa-floppy-disk"></i>Save</button>
    </div>
    <div class="divider"></div>
    <div class="group">
      <button class="btn active" data-tool="select"><i class="fa-solid fa-arrow-pointer"></i>Select</button>
      <div class="divider"></div>
      <button class="btn" data-tool="text"><i class="fa-solid fa-font"></i>Text</button>
      <button class="btn" data-tool="whiteout"><i class="fa-solid fa-eraser"></i>Whiteout</button>
      <button class="btn" data-tool="image"><i class="fa-regular fa-image"></i>Image</button>
    </div>
    <div class="divider"></div>
    <div class="group">
      <button class="btn" id="delete-btn" title="Delete"><i class="fa-regular fa-trash-can" style="color:#ef4444;"></i></button>
    </div>
    <div class="divider"></div>
    <div class="group">
      <button class="btn" id="zoom-out"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
      <span id="zoom-label" style="font-size:12px; color:#475569; min-width:48px; text-align:center;">100%</span>
      <button class="btn" id="zoom-in"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
    </div>
  </div>

  <!-- Property Bar -->
  <div class="prop-bar">
    <div class="group" style="gap:8px;">
      <label style="font-size:11px; color:#94a3b8; font-weight:600;">Font</label>
      <select id="font-family">
        <option value="BankCourier">Bank Courier (Courier Prime)</option>
        <option value="Helvetica">Helvetica</option>
        <option value="Times">Times New Roman</option>
      </select>
      <div class="divider" style="height:20px;"></div>
      <input type="number" id="font-size" value="12" min="6" max="96" title="Size" />
      <button class="toggle" id="bold-toggle" title="Bold / Darkness">B</button>
      <input type="color" id="font-color" value="#000000" title="Color" />
      <div class="divider" style="height:20px;"></div>
      <div class="slider-wrap">
        <span>Letter spacing</span>
        <input type="range" id="letter-spacing" min="-2" max="10" step="0.1" value="0" />
        <span id="ls-val" style="width:42px; text-align:right;">0px</span>
      </div>
      <div class="slider-wrap">
        <span>Stretch</span>
        <input type="range" id="stretch" min="50" max="150" step="1" value="100" />
        <span id="st-val" style="width:42px; text-align:right;">100%</span>
      </div>
    </div>
    <div style="flex:1;"></div>
  </div>

  <!-- Workspace -->
  <div id="workspace">
    <div id="canvas-wrapper">
      <canvas id="pdf-canvas"></canvas>
      <canvas id="overlay"></canvas>
      <textarea id="text-editor"></textarea>
    </div>
    <div class="drop-overlay" id="drop-overlay">
      <i class="fa-solid fa-cloud-arrow-up fa-3x"></i>
      <div>Drop PDF Here</div>
    </div>
  </div>

  <!-- Hidden inputs -->
  <input type="file" id="file-input" accept="application/pdf" style="display:none" />
  <input type="file" id="img-input" accept="image/png,image/jpeg" style="display:none" />

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // State
    const S = {
      pdfBytes: null,
      pdfDoc: null,
      pdfLibDoc: null,
      pageNum: 1,
      scale: 1.0,
      tool: 'select',
      objects: [], // {id,type,x,y,w,h,text,font,size,color,ls,stretch,bold,img,imgFile}
      selected: null,
      isDragging: false,
      dragOffset: {x:0,y:0},
      resizing: null, // handle name
      newRectStart: null,
      editing: false,
      textItems: [], // pdf.js text items for font detection
    };

    // DOM refs
    const pdfCanvas = document.getElementById('pdf-canvas');
    const overlay = document.getElementById('overlay');
    const pdfCtx = pdfCanvas.getContext('2d');
    const octx = overlay.getContext('2d');
    const editor = document.getElementById('text-editor');
    const wrapper = document.getElementById('canvas-wrapper');

    // Controls
    const fontSel = document.getElementById('font-family');
    const sizeInp = document.getElementById('font-size');
    const colorInp = document.getElementById('font-color');
    const boldBtn = document.getElementById('bold-toggle');
    const lsInp = document.getElementById('letter-spacing');
    const stInp = document.getElementById('stretch');
    const lsVal = document.getElementById('ls-val');
    const stVal = document.getElementById('st-val');
    const zoomLabel = document.getElementById('zoom-label');

    // Helpers
    const genId = () => crypto.randomUUID();
    const mapFontCanvas = f => f === 'BankCourier' ? '"Courier Prime", Courier, monospace'
                        : f === 'Times' ? '"Times New Roman", Times, serif'
                        : 'Helvetica, Arial, sans-serif';
    const mapFontPdf = (f,bold) => {
      if (f === 'BankCourier') return bold ? PDFLib.StandardFonts.CourierBold : PDFLib.StandardFonts.Courier;
      if (f === 'Times') return PDFLib.StandardFonts.TimesRoman;
      return bold ? PDFLib.StandardFonts.HelveticaBold : PDFLib.StandardFonts.Helvetica;
    };
    const isMono = (item) => {
      // heuristic: fontName contains "Mono" or char widths are nearly equal
      if ((item.fontName||'').toLowerCase().includes('mono')) return true;
      if (item.width && item.str && item.str.length>1) {
        const avg = item.width / item.str.length;
        let dev = 0;
        for (const ch of item.str) {
          const w = item.width / item.str.length;
          dev += Math.abs(w-avg);
        }
        return dev / item.str.length < 0.2 * avg;
      }
      return false;
    };

    // Init UI
    document.querySelectorAll('[data-tool]').forEach(btn=>{
      btn.addEventListener('click', ()=>setTool(btn.dataset.tool));
    });
    document.getElementById('open-btn').onclick = ()=>document.getElementById('file-input').click();
    document.getElementById('file-input').onchange = e=>{ if(e.target.files[0]) openPDF(e.target.files[0]); };
    document.getElementById('save-btn').onclick = savePDF;
    document.getElementById('zoom-in').onclick = ()=>{ S.scale=Math.min(3,S.scale+0.1); renderPage(); };
    document.getElementById('zoom-out').onclick = ()=>{ S.scale=Math.max(0.4,S.scale-0.1); renderPage(); };
    document.getElementById('delete-btn').onclick = deleteSelected;
    document.getElementById('img-input').onchange = handleImage;

    [fontSel,sizeInp,colorInp,lsInp,stInp].forEach(el=>el.addEventListener('input',applySelectionProps));
    boldBtn.onclick = ()=>{ boldBtn.classList.toggle('toggled'); applySelectionProps(); };
    lsInp.addEventListener('input',()=>{lsVal.textContent=lsInp.value+'px';});
    stInp.addEventListener('input',()=>{stVal.textContent=stInp.value+'%';});

    // Drag-drop PDF
    const dropOverlay = document.getElementById('drop-overlay');
    ['dragenter','dragover'].forEach(ev=>document.addEventListener(ev,(e)=>{e.preventDefault(); dropOverlay.classList.add('active');}));
    ['dragleave','drop'].forEach(ev=>document.addEventListener(ev,(e)=>{e.preventDefault(); dropOverlay.classList.remove('active');}));
    document.addEventListener('drop',(e)=>{ if(e.dataTransfer.files[0]) openPDF(e.dataTransfer.files[0]); });

    // Canvas interactions
    overlay.addEventListener('mousedown', onDown);
    overlay.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    overlay.addEventListener('dblclick', onDbl);

    // Keyboard
    document.addEventListener('keydown',(e)=>{
      if (S.selected && !S.editing) {
        const obj = S.objects.find(o=>o.id===S.selected);
        if (!obj) return;
        let step = e.shiftKey ? 10 : 1;
        let moved=false;
        if (e.key==='ArrowLeft'){obj.x-=step; moved=true;}
        if (e.key==='ArrowRight'){obj.x+=step; moved=true;}
        if (e.key==='ArrowUp'){obj.y-=step; moved=true;}
        if (e.key==='ArrowDown'){obj.y+=step; moved=true;}
        if (moved){e.preventDefault(); redraw();}
      }
      if (e.key==='Delete' || e.key==='Backspace') { deleteSelected(); }
    });

    // Zoom by ctrl+scroll
    overlay.addEventListener('wheel',(e)=>{
      if (e.ctrlKey){
        e.preventDefault();
        S.scale = Math.min(3, Math.max(0.4, S.scale + (e.deltaY<0?0.05:-0.05)));
        renderPage();
      }
    }, {passive:false});

    // Editor blur
    editor.addEventListener('blur', commitEdit);
    editor.addEventListener('keydown',(e)=>{
      if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); commitEdit(); }
      if (e.key==='Escape'){ cancelEdit(); }
    });

    function setTool(t){
      if (S.editing) commitEdit();
      S.tool=t;
      document.querySelectorAll('[data-tool]').forEach(btn=>btn.classList.toggle('active',btn.dataset.tool===t));
      overlay.style.cursor = t==='select'?'default':(t==='image'?'copy':'crosshair');
      if (t!=='select') S.selected=null;
      redraw();
    }

    async function openPDF(file){
      S.pdfBytes = await file.arrayBuffer();
      S.pdfDoc = await pdfjsLib.getDocument({data:S.pdfBytes}).promise;
      S.pdfLibDoc = await PDFLib.PDFDocument.load(S.pdfBytes);
      S.pageNum = 1;
      S.objects = [];
      S.selected = null;
      document.getElementById('save-btn').disabled = false;
      await renderPage();
    }

    async function renderPage(){
      if (!S.pdfDoc) return;
      const page = await S.pdfDoc.getPage(S.pageNum);
      const viewport = page.getViewport({scale:S.scale});
      [pdfCanvas, overlay].forEach(c=>{
        c.width = viewport.width; c.height = viewport.height;
      });
      wrapper.style.width = viewport.width+'px';
      wrapper.style.height = viewport.height+'px';
      await page.render({canvasContext:pdfCtx, viewport}).promise;

      // capture text items for smart detection
      const textContent = await page.getTextContent();
      S.textItems = textContent.items.map(it=>{
        const tx = it.transform;
        const fontSize = Math.hypot(tx[0], tx[1]);
        // approximate bbox
        const w = it.width;
        const h = fontSize;
        const x = tx[4];
        const y = viewport.height - tx[5];
        return { ...it, bbox:{x, y-h, w, h}, fontSize };
      });

      zoomLabel.textContent = Math.round(S.scale*100)+'%';
      redraw();
    }

    function redraw(){
      octx.clearRect(0,0,overlay.width,overlay.height);
      // Draw objects
      for (const obj of S.objects){
        drawObj(obj);
      }
      // selection
      if (S.selected && !S.editing){
        const obj = S.objects.find(o=>o.id===S.selected);
        if (obj) drawSelection(obj);
      }
    }

    function drawObj(o){
      const x = o.x * S.scale, y = o.y * S.scale, w = o.w * S.scale, h = o.h * S.scale;
      if (o.type==='whiteout'){
        octx.fillStyle='#fff';
        octx.fillRect(x,y,w,h);
      } else if (o.type==='image' && o.img){
        octx.drawImage(o.img,x,y,w,h);
      } else if (o.type==='text'){
        octx.save();
        octx.fillStyle = o.color || '#000';
        const weight = o.bold ? 'bold ' : '';
        octx.font = `${weight}${o.size * S.scale}px ${mapFontCanvas(o.font)}`;
        octx.textBaseline='top';
        octx.translate(x,y);
        octx.scale(o.stretch||1,1);
        drawSpaced(octx, o.text, 0,0, (o.ls||0)*S.scale);
        octx.restore();
      }
    }
    function drawSpaced(ctx2d, text, x, y, ls){
      let cur=x;
      for(const ch of text){
        ctx2d.fillText(ch, cur, y);
        cur += ctx2d.measureText(ch).width + ls;
      }
    }

    function drawSelection(o){
      const x = o.x*S.scale, y=o.y*S.scale, w=o.w*S.scale, h=o.h*S.scale;
      octx.save();
      octx.strokeStyle = '#cceeff';
      octx.lineWidth = 2;
      octx.setLineDash([4,2]);
      octx.strokeRect(x,y,w,h);
      octx.setLineDash([]);
      octx.strokeStyle = '#8ecae6';
      octx.strokeRect(x,y,w,h);
      // handles
      const pts = [[x,y],[x+w,y],[x,y+h],[x+w,y+h]];
      octx.fillStyle='#fff';
      octx.lineWidth=2;
      octx.strokeStyle='#8ecae6';
      for(const [hx,hy] of pts){
        octx.fillRect(hx-5,hy-5,10,10);
        octx.strokeRect(hx-5,hy-5,10,10);
      }
      octx.restore();
    }

    function onDown(e){
      const pos = getPos(e);
      if (S.tool==='select'){
        const hit = hitTest(pos.x,pos.y);
        if (hit){
          S.selected = hit.id;
          const handle = handleHit(hit,pos.x,pos.y);
          if (handle){
            S.resizing = handle;
          } else {
            S.isDragging=true;
            S.dragOffset={x:pos.x-hit.x,y:pos.y-hit.y};
          }
          syncProps(hit);
        } else {
          S.selected=null;
        }
        redraw();
      } else if (S.tool==='whiteout'){
        S.newRectStart = pos;
      } else if (S.tool==='text'){
        // Smart detection: try find text item under click
        const item = textHit(pos.x,pos.y);
        if (item){
          if (isMono(item)) fontSel.value='BankCourier';
          const sz = Math.round(item.fontSize);
          sizeInp.value = sz;
          syncLsStDisplay();
        }
        createTextAt(pos.x,pos.y);
      } else if (S.tool==='image'){
        document.getElementById('img-input').click();
      }
    }

    function onMove(e){
      const pos = getPos(e);
      if (S.tool==='whiteout' && S.newRectStart){
        redraw();
        const x0=S.newRectStart.x*S.scale, y0=S.newRectStart.y*S.scale;
        const w=pos.rawX - x0, h=pos.rawY - y0;
        octx.fillStyle='rgba(204,238,255,0.25)';
        octx.strokeStyle='#0066cc';
        octx.fillRect(x0,y0,w,h); octx.strokeRect(x0,y0,w,h);
      }
      if (S.isDragging && S.selected){
        const obj = S.objects.find(o=>o.id===S.selected);
        if (obj){
          obj.x = pos.x - S.dragOffset.x;
          obj.y = pos.y - S.dragOffset.y;
          redraw();
        }
      }
      if (S.resizing && S.selected){
        const o = S.objects.find(o=>o.id===S.selected);
        if (o){
          resizeObj(o, S.resizing, pos.x, pos.y);
          redraw();
        }
      }
    }

    function onUp(e){
      if (S.tool==='whiteout' && S.newRectStart){
        const pos = getPos(e);
        const x = Math.min(pos.x, S.newRectStart.x);
        const y = Math.min(pos.y, S.newRectStart.y);
        const w = Math.abs(pos.x - S.newRectStart.x);
        const h = Math.abs(pos.y - S.newRectStart.y);
        if (w>2 && h>2){
          const obj={id:genId(), type:'whiteout', x,y,w,h};
          S.objects.push(obj);
          S.selected = obj.id;
        }
        S.newRectStart=null; redraw();
      }
      S.isDragging=false; S.resizing=null;
    }

    function onDbl(e){
      const pos = getPos(e);
      const hit = hitTest(pos.x,pos.y);
      if (hit && hit.type==='text'){
        S.selected = hit.id;
        startEdit(hit);
      }
    }

    function hitTest(x,y){
      for (let i=S.objects.length-1;i>=0;i--){
        const o=S.objects[i];
        if (x>=o.x && x<=o.x+o.w && y>=o.y && y<=o.y+o.h) return o;
      }
      return null;
    }
    function handleHit(o,x,y){
      const hs=6;
      const corners=[
        {n:'nw',x:o.x,y:o.y},
        {n:'ne',x:o.x+o.w,y:o.y},
        {n:'sw',x:o.x,y:o.y+o.h},
        {n:'se',x:o.x+o.w,y:o.y+o.h},
      ];
      for (const c of corners){
        if (Math.abs(x-c.x)<=hs && Math.abs(y-c.y)<=hs) return c.n;
      }
      return null;
    }
    function resizeObj(o,handle,x,y){
      const min=4;
      if (handle==='nw'){ const nx=Math.min(o.x+o.w-min,x); const ny=Math.min(o.y+o.h-min,y); o.w=o.x+o.w-nx; o.h=o.y+o.h-ny; o.x=nx; o.y=ny; }
      if (handle==='ne'){ const ny=Math.min(o.y+o.h-min,y); o.w=Math.max(min,x-o.x); o.h=o.y+o.h-ny; o.y=ny; }
      if (handle==='sw'){ const nx=Math.min(o.x+o.w-min,x); o.w=o.x+o.w-nx; o.h=Math.max(min,y-o.y); o.x=nx; }
      if (handle==='se'){ o.w=Math.max(min,x-o.x); o.h=Math.max(min,y-o.y); }
    }

    // Text creation with auto mask
    function createTextAt(x,y){
      const maskId = genId();
      const textId = genId();
      const size = parseInt(sizeInp.value)||12;
      const h = size*1.2;
      const w = 120;

      // whiteout mask behind text
      S.objects.push({id:maskId,type:'whiteout',x,y,w,h});

      const obj = {
        id:textId,type:'text',x,y,w,h,
        text:'',
        font: fontSel.value,
        size,
        color: colorInp.value,
        ls: parseFloat(lsInp.value)||0,
        stretch: (parseInt(stInp.value)||100)/100,
        bold: boldBtn.classList.contains('toggled'),
        maskId
      };
      S.objects.push(obj);
      S.selected = textId;
      startEdit(obj);
    }

    function startEdit(obj){
      S.editing=true;
      const x = obj.x*S.scale, y=obj.y*S.scale;
      editor.style.display='block';
      editor.style.left = x+'px';
      editor.style.top  = y+'px';
      editor.style.minWidth = (obj.w*S.scale)+'px';
      editor.style.height = (obj.h*S.scale)+'px';
      editor.style.fontFamily = mapFontCanvas(obj.font);
      editor.style.fontSize = (obj.size*S.scale)+'px';
      editor.style.color = obj.color;
      editor.style.fontWeight = obj.bold?'700':'400';
      editor.style.letterSpacing = (obj.ls*S.scale)+'px';
      editor.style.transform = `scaleX(${obj.stretch||1})`;
      editor.value = obj.text;
      editor.focus();
      redraw();
    }
    function commitEdit(){
      if (!S.editing) return;
      const obj = S.objects.find(o=>o.id===S.selected);
      if (obj && obj.type==='text'){
        obj.text = editor.value;
        // measure width
        octx.save();
        octx.font = `${obj.bold?'bold ':''}${obj.size}px ${mapFontCanvas(obj.font)}`;
        const w = measureSpaced(octx,obj.text,obj.ls)*(obj.stretch||1);
        obj.w = Math.max(12, w);
        obj.h = obj.size*1.2;
        octx.restore();
        // sync mask
        if (obj.maskId){
          const m = S.objects.find(o=>o.id===obj.maskId);
          if (m){ m.x=obj.x; m.y=obj.y; m.w=obj.w; m.h=obj.h; }
        }
      }
      editor.style.display='none';
      S.editing=false;
      redraw();
    }
    function cancelEdit(){
      S.editing=false; editor.style.display='none'; redraw();
    }
    function measureSpaced(ctx,text,ls){
      let w=0;
      for(const ch of text){ w+=ctx.measureText(ch).width + ls; }
      return w - ls;
    }

    function applySelectionProps(){
      const obj = S.objects.find(o=>o.id===S.selected);
      if (!obj || obj.type!=='text') return;
      obj.font = fontSel.value;
      obj.size = parseInt(sizeInp.value)||12;
      obj.color = colorInp.value;
      obj.ls = parseFloat(lsInp.value)||0;
      obj.stretch = (parseInt(stInp.value)||100)/100;
      obj.bold = boldBtn.classList.contains('toggled');
      // recompute size
      octx.save();
      octx.font = `${obj.bold?'bold ':''}${obj.size}px ${mapFontCanvas(obj.font)}`;
      obj.w = measureSpaced(octx,obj.text,obj.ls)*(obj.stretch||1);
      obj.h = obj.size*1.2;
      octx.restore();
      if (obj.maskId){
        const m = S.objects.find(o=>o.id===obj.maskId);
        if (m){ m.x=obj.x; m.y=obj.y; m.w=obj.w; m.h=obj.h; }
      }
      if (S.editing){
        editor.style.fontFamily = mapFontCanvas(obj.font);
        editor.style.fontSize = (obj.size*S.scale)+'px';
        editor.style.color = obj.color;
        editor.style.fontWeight = obj.bold?'700':'400';
        editor.style.letterSpacing = (obj.ls*S.scale)+'px';
        editor.style.transform = `scaleX(${obj.stretch||1})`;
      }
      redraw();
    }

    function syncProps(obj){
      if (!obj || obj.type!=='text') return;
      fontSel.value = obj.font;
      sizeInp.value = obj.size;
      colorInp.value = obj.color;
      lsInp.value = obj.ls||0; lsVal.textContent=lsInp.value+'px';
      stInp.value = Math.round((obj.stretch||1)*100); stVal.textContent=stInp.value+'%';
      boldBtn.classList.toggle('toggled', !!obj.bold);
    }

    function textHit(x,y){
      return S.textItems.find(it=>{
        const b=it.bbox;
        return x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h;
      });
    }

    function deleteSelected(){
      if (!S.selected) return;
      const obj = S.objects.find(o=>o.id===S.selected);
      if (obj && obj.maskId){
        S.objects = S.objects.filter(o=>o.id!==obj.maskId);
      }
      S.objects = S.objects.filter(o=>o.id!==S.selected);
      S.selected=null; redraw();
    }

    async function handleImage(e){
      const f = e.target.files[0];
      if (!f) return;
      const img = new Image();
      img.onload = ()=>{
        const ratio = img.height/img.width;
        const w=180, h=180*ratio;
        const obj={id:genId(), type:'image', x:40, y:40, w, h, img, imgFile:f};
        S.objects.push(obj); S.selected=obj.id; redraw();
      };
      img.src = URL.createObjectURL(f);
    }

    async function savePDF(){
      if (!S.pdfLibDoc) return;
      const doc = await PDFLib.PDFDocument.load(S.pdfBytes);
      const page = doc.getPages()[S.pageNum-1];
      const {height} = page.getSize();

      const fontCache = {};
      async function getFont(f,b){
        const key=f+(b?'b':'n');
        if (fontCache[key]) return fontCache[key];
        const name = mapFontPdf(f,b);
        const font = await doc.embedFont(name);
        fontCache[key]=font; return font;
      }

      for (const o of S.objects){
        if (o.type==='whiteout'){
          page.drawRectangle({
            x:o.x, y:height - (o.y + o.h),
            width:o.w, height:o.h,
            color: PDFLib.rgb(1,1,1)
          });
        } else if (o.type==='text'){
          const font = await getFont(o.font, o.bold);
          const col = hexToRgb(o.color||'#000000');
          const size = o.size;
          const ls = o.ls||0;
          const stretch = o.stretch||1;
          let cur = o.x;
          const baseY = height - o.y - size*0.8;
          for (const ch of o.text){
            const w = font.widthOfTextAtSize(ch, size)*stretch;
            page.drawText(ch,{
              x:cur, y:baseY,
              size, font,
              xScale: stretch,
              color: PDFLib.rgb(col.r/255,col.g/255,col.b/255)
            });
            cur += w + ls;
          }
        } else if (o.type==='image' && o.imgFile){
          const bytes = await o.imgFile.arrayBuffer();
          let embedded;
          if (o.imgFile.type==='image/png') embedded = await doc.embedPng(bytes);
          else embedded = await doc.embedJpg(bytes);
          page.drawImage(embedded,{
            x:o.x, y:height - (o.y + o.h),
            width:o.w, height:o.h
          });
        }
      }
      const out = await doc.save();
      const blob = new Blob([out], {type:'application/pdf'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob); a.download='Alta_Edited.pdf'; a.click();
      URL.revokeObjectURL(a.href);
    }

    function hexToRgb(hex){
      const v=parseInt(hex.slice(1),16);
      return {r:(v>>16)&255, g:(v>>8)&255, b:v&255};
    }

    function getPos(e){
      const rect=overlay.getBoundingClientRect();
      const rawX = e.clientX - rect.left;
      const rawY = e.clientY - rect.top;
      return {x: rawX / S.scale, y: rawY / S.scale, rawX, rawY};
    }

    function syncLsStDisplay(){
      lsVal.textContent = lsInp.value + 'px';
      stVal.textContent = stInp.value + '%';
    }

    // Start
    setTool('select');
    syncLsStDisplay();
  </script>
</body>
</html>
